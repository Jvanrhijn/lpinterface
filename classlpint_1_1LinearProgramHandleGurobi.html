<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>lpinterface: lpint::LinearProgramHandleGurobi Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">lpinterface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelpint.html">lpint</a></li><li class="navelem"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html">LinearProgramHandleGurobi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlpint_1_1LinearProgramHandleGurobi-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lpint::LinearProgramHandleGurobi Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for lpint::LinearProgramHandleGurobi:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlpint_1_1LinearProgramHandleGurobi.png" usemap="#lpint::LinearProgramHandleGurobi_map" alt=""/>
  <map id="lpint::LinearProgramHandleGurobi_map" name="lpint::LinearProgramHandleGurobi_map">
<area href="classlpint_1_1ILinearProgramHandle.html" title="Interface representing linear program formulation. This interface represents linear programs of the f..." alt="lpint::ILinearProgramHandle" shape="rect" coords="0,0,203,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59919585e59d25e8881e7c98d879086b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59919585e59d25e8881e7c98d879086b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LinearProgramHandleGurobi</b> (<a class="el" href="classlpint_1_1detail_1_1Badge.html">detail::Badge</a>&lt; <a class="el" href="classlpint_1_1GurobiSolver.html">GurobiSolver</a> &gt;, std::shared_ptr&lt; GRBmodel &gt; grbmodel, std::shared_ptr&lt; GRBenv &gt; grbenv)</td></tr>
<tr class="separator:a59919585e59d25e8881e7c98d879086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757b7f2be00535caca754bd9c9602d15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a757b7f2be00535caca754bd9c9602d15"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a757b7f2be00535caca754bd9c9602d15">num_vars</a> () const override</td></tr>
<tr class="memdesc:a757b7f2be00535caca754bd9c9602d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of variables in the LP. <br/></td></tr>
<tr class="separator:a757b7f2be00535caca754bd9c9602d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de9eef01a022db6fef74c032a36e533"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8de9eef01a022db6fef74c032a36e533"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a8de9eef01a022db6fef74c032a36e533">num_constraints</a> () const override</td></tr>
<tr class="memdesc:a8de9eef01a022db6fef74c032a36e533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cosntraints in the LP. <br/></td></tr>
<tr class="separator:a8de9eef01a022db6fef74c032a36e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cbdd46fbc0c8684a33b8d1f8dc7250"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4cbdd46fbc0c8684a33b8d1f8dc7250"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#aa4cbdd46fbc0c8684a33b8d1f8dc7250">set_objective_sense</a> (const <a class="el" href="namespacelpint.html#a5b73e21a898199ee50d8dcf5e7742c01">OptimizationType</a> objsense) override</td></tr>
<tr class="memdesc:aa4cbdd46fbc0c8684a33b8d1f8dc7250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the objective sense of this <a class="el" href="classlpint_1_1ILinearProgramHandle.html" title="Interface representing linear program formulation. This interface represents linear programs of the f...">ILinearProgramHandle</a>. The Optimization type can be either <a class="el" href="namespacelpint.html#a5b73e21a898199ee50d8dcf5e7742c01ad27532d90ecd513e97ab811c0f34dbfd" title="Maximize the objective function value. ">OptimizationType::Minimize</a> or <a class="el" href="namespacelpint.html#a5b73e21a898199ee50d8dcf5e7742c01a9369ba148ee259473fc1fb4939b6c2e8" title="Minimize the objective function value. ">OptimizationType::Maximize</a>, which correspond to the LP formulations min c^T * x and max c^T * x, respectively. <br/></td></tr>
<tr class="separator:aa4cbdd46fbc0c8684a33b8d1f8dc7250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb278eeedf4fdeb7e7756d09692fe9df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlpint_1_1Variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#acb278eeedf4fdeb7e7756d09692fe9df">variable</a> (std::size_t i) const override</td></tr>
<tr class="memdesc:acb278eeedf4fdeb7e7756d09692fe9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve variable i from the internal LP solver.  <a href="#acb278eeedf4fdeb7e7756d09692fe9df">More...</a><br/></td></tr>
<tr class="separator:acb278eeedf4fdeb7e7756d09692fe9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293508ed47cf1fa360d32cd7a2fe1acd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlpint_1_1Variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a293508ed47cf1fa360d32cd7a2fe1acd">variables</a> () const override</td></tr>
<tr class="memdesc:a293508ed47cf1fa360d32cd7a2fe1acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the variables from the internal LP solver.  <a href="#a293508ed47cf1fa360d32cd7a2fe1acd">More...</a><br/></td></tr>
<tr class="separator:a293508ed47cf1fa360d32cd7a2fe1acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7ee5a86ed3236c5eae376ffabe529f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#aee7ee5a86ed3236c5eae376ffabe529f">add_variables</a> (const std::vector&lt; <a class="el" href="classlpint_1_1Variable.html">Variable</a> &gt; &amp;vars) override</td></tr>
<tr class="memdesc:aee7ee5a86ed3236c5eae376ffabe529f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add variables to the LP.  <a href="#aee7ee5a86ed3236c5eae376ffabe529f">More...</a><br/></td></tr>
<tr class="separator:aee7ee5a86ed3236c5eae376ffabe529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e291c921fc9b93cdae073b5b86303e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22e291c921fc9b93cdae073b5b86303e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a22e291c921fc9b93cdae073b5b86303e">add_variables</a> (const std::size_t <a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a757b7f2be00535caca754bd9c9602d15">num_vars</a>) override</td></tr>
<tr class="memdesc:a22e291c921fc9b93cdae073b5b86303e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add num_vars non-negative variables to the LP. To be called before settings the objective function. <br/></td></tr>
<tr class="separator:a22e291c921fc9b93cdae073b5b86303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57448d607b6f0ce62c6b22a96cf43e5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57448d607b6f0ce62c6b22a96cf43e5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a57448d607b6f0ce62c6b22a96cf43e5a">add_constraints</a> (const std::vector&lt; <a class="el" href="structlpint_1_1Constraint.html">Constraint</a>&lt; double &gt;&gt; &amp;<a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#ac6349ec185ac34c83ae269ad6131f704">constraints</a>) override</td></tr>
<tr class="memdesc:a57448d607b6f0ce62c6b22a96cf43e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of constraints to the LP formulation. This can only be called after calling <a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#ab880dd439aef6fd6f5f3a2475c1c2554" title="Set the objective function to be used. This method must be called before calling add_constraints(). ">set_objective()</a>. <br/></td></tr>
<tr class="separator:a57448d607b6f0ce62c6b22a96cf43e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba12d8c2dfc3e7303dc67874534278a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a2ba12d8c2dfc3e7303dc67874534278a">remove_variable</a> (const std::size_t i) override</td></tr>
<tr class="memdesc:a2ba12d8c2dfc3e7303dc67874534278a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a variable from the LP.  <a href="#a2ba12d8c2dfc3e7303dc67874534278a">More...</a><br/></td></tr>
<tr class="separator:a2ba12d8c2dfc3e7303dc67874534278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fda3e9b72ded006264ff0dc39da3e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a8fda3e9b72ded006264ff0dc39da3e32">remove_constraint</a> (std::size_t i) override</td></tr>
<tr class="memdesc:a8fda3e9b72ded006264ff0dc39da3e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a constraint from the LP.  <a href="#a8fda3e9b72ded006264ff0dc39da3e32">More...</a><br/></td></tr>
<tr class="separator:a8fda3e9b72ded006264ff0dc39da3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfa02d83e19004a4cde7dfb33edccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8bfa02d83e19004a4cde7dfb33edccc"></a>
<a class="el" href="namespacelpint.html#a5b73e21a898199ee50d8dcf5e7742c01">OptimizationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#ab8bfa02d83e19004a4cde7dfb33edccc">optimization_type</a> () const override</td></tr>
<tr class="memdesc:ab8bfa02d83e19004a4cde7dfb33edccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the objective sense of this <a class="el" href="classlpint_1_1ILinearProgramHandle.html" title="Interface representing linear program formulation. This interface represents linear programs of the f...">ILinearProgramHandle</a>. The Optimization type can be either <a class="el" href="namespacelpint.html#a5b73e21a898199ee50d8dcf5e7742c01ad27532d90ecd513e97ab811c0f34dbfd" title="Maximize the objective function value. ">OptimizationType::Minimize</a> or <a class="el" href="namespacelpint.html#a5b73e21a898199ee50d8dcf5e7742c01a9369ba148ee259473fc1fb4939b6c2e8" title="Minimize the objective function value. ">OptimizationType::Maximize</a>, which correspond to the LP formulations min c^T * x and max c^T * x, respectively. <br/></td></tr>
<tr class="separator:ab8bfa02d83e19004a4cde7dfb33edccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab880dd439aef6fd6f5f3a2475c1c2554"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab880dd439aef6fd6f5f3a2475c1c2554"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#ab880dd439aef6fd6f5f3a2475c1c2554">set_objective</a> (const <a class="el" href="structlpint_1_1Objective.html">Objective</a>&lt; double &gt; &amp;<a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a4ea47e04c749b212d1d7d408bcd8283f">objective</a>) override</td></tr>
<tr class="memdesc:ab880dd439aef6fd6f5f3a2475c1c2554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the objective function to be used. This method must be called before calling <a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a57448d607b6f0ce62c6b22a96cf43e5a" title="Add a set of constraints to the LP formulation. This can only be called after calling set_objective()...">add_constraints()</a>. <br/></td></tr>
<tr class="separator:ab880dd439aef6fd6f5f3a2475c1c2554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd28ff295f86b288904e9db9cfcad02"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structlpint_1_1Constraint.html">Constraint</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#aafd28ff295f86b288904e9db9cfcad02">constraint</a> (std::size_t i) const override</td></tr>
<tr class="memdesc:aafd28ff295f86b288904e9db9cfcad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve constraint i of the internal LP. This method requests a constraint from the internal LP solver backend, copies it, and returns it. Since constraints have to be copied from the backend, this can be an expensive operation, and so should be used sparingly.  <a href="#aafd28ff295f86b288904e9db9cfcad02">More...</a><br/></td></tr>
<tr class="separator:aafd28ff295f86b288904e9db9cfcad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6349ec185ac34c83ae269ad6131f704"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structlpint_1_1Constraint.html">Constraint</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#ac6349ec185ac34c83ae269ad6131f704">constraints</a> () const override</td></tr>
<tr class="memdesc:ac6349ec185ac34c83ae269ad6131f704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the constraints of the internal LP. This method requests the constraints from the internal LP solver backend, copies them, and returns them in a vector. Since the constraints have to be copied from the backend, this can be quite an expensive operation, and so should not be called in a loop.  <a href="#ac6349ec185ac34c83ae269ad6131f704">More...</a><br/></td></tr>
<tr class="separator:ac6349ec185ac34c83ae269ad6131f704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea47e04c749b212d1d7d408bcd8283f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlpint_1_1Objective.html">Objective</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlpint_1_1LinearProgramHandleGurobi.html#a4ea47e04c749b212d1d7d408bcd8283f">objective</a> () const override</td></tr>
<tr class="memdesc:a4ea47e04c749b212d1d7d408bcd8283f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the objective function of the internal LP. This method requests the objective function values from the LP backend, copies them, and returns them. Since the objective values have to be copied from the backend, this can be quite an expensive operation, and so should not be called in a loop.  <a href="#a4ea47e04c749b212d1d7d408bcd8283f">More...</a><br/></td></tr>
<tr class="separator:a4ea47e04c749b212d1d7d408bcd8283f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dfc009d5d88910b23dc69ae9614b96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40dfc009d5d88910b23dc69ae9614b96"></a>
std::shared_ptr&lt; GRBmodel &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gurobi_model</b> (<a class="el" href="classlpint_1_1detail_1_1Badge.html">detail::Badge</a>&lt; <a class="el" href="classlpint_1_1GurobiSolver.html">GurobiSolver</a> &gt;) const </td></tr>
<tr class="separator:a40dfc009d5d88910b23dc69ae9614b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244b1cc5ed0be5c20333a4e356aad826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a244b1cc5ed0be5c20333a4e356aad826"></a>
std::shared_ptr&lt; GRBenv &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gurobi_env</b> (<a class="el" href="classlpint_1_1detail_1_1Badge.html">detail::Badge</a>&lt; <a class="el" href="classlpint_1_1GurobiSolver.html">GurobiSolver</a> &gt;) const </td></tr>
<tr class="separator:a244b1cc5ed0be5c20333a4e356aad826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64338df73b7bc5cb929308e35a56d6dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64338df73b7bc5cb929308e35a56d6dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_num_vars</b> (<a class="el" href="classlpint_1_1detail_1_1Badge.html">detail::Badge</a>&lt; <a class="el" href="classlpint_1_1GurobiSolver.html">GurobiSolver</a> &gt;, std::size_t nvars)</td></tr>
<tr class="separator:a64338df73b7bc5cb929308e35a56d6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlpint_1_1ILinearProgramHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlpint_1_1ILinearProgramHandle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlpint_1_1ILinearProgramHandle.html">lpint::ILinearProgramHandle</a></td></tr>
<tr class="memitem:aa37bdf75f1e46b6a28fe1f4c2f4d0940 inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa37bdf75f1e46b6a28fe1f4c2f4d0940"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ILinearProgramHandle</b> (const <a class="el" href="classlpint_1_1ILinearProgramHandle.html">ILinearProgramHandle</a> &amp;)=default</td></tr>
<tr class="separator:aa37bdf75f1e46b6a28fe1f4c2f4d0940 inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8fd1f885bbf905e69fb6fbae22321d inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f8fd1f885bbf905e69fb6fbae22321d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ILinearProgramHandle</b> (<a class="el" href="classlpint_1_1ILinearProgramHandle.html">ILinearProgramHandle</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a4f8fd1f885bbf905e69fb6fbae22321d inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ee0f4bb9b2f5d305af840513d39f78 inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ee0f4bb9b2f5d305af840513d39f78"></a>
<a class="el" href="classlpint_1_1ILinearProgramHandle.html">ILinearProgramHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlpint_1_1ILinearProgramHandle.html">ILinearProgramHandle</a> &amp;)=default</td></tr>
<tr class="separator:a99ee0f4bb9b2f5d305af840513d39f78 inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e83a23cdc6cb9e8726cdbfca668201 inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e83a23cdc6cb9e8726cdbfca668201"></a>
<a class="el" href="classlpint_1_1ILinearProgramHandle.html">ILinearProgramHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlpint_1_1ILinearProgramHandle.html">ILinearProgramHandle</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac7e83a23cdc6cb9e8726cdbfca668201 inherit pub_methods_classlpint_1_1ILinearProgramHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aee7ee5a86ed3236c5eae376ffabe529f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lpint::LinearProgramHandleGurobi::add_variables </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlpint_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add variables to the LP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>Vector of variables to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#a944ca072d923199bfda04f0532b32f14">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="aafd28ff295f86b288904e9db9cfcad02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structlpint_1_1Constraint.html">Constraint</a>&lt;double&gt; lpint::LinearProgramHandleGurobi::constraint </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve constraint i of the internal LP. This method requests a constraint from the internal LP solver backend, copies it, and returns it. Since constraints have to be copied from the backend, this can be an expensive operation, and so should be used sparingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constraint&lt;double&gt; </dd></dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#ae04527310037420703906994555a0792">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="ac6349ec185ac34c83ae269ad6131f704"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structlpint_1_1Constraint.html">Constraint</a>&lt;double&gt; &gt; lpint::LinearProgramHandleGurobi::constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the constraints of the internal LP. This method requests the constraints from the internal LP solver backend, copies them, and returns them in a vector. Since the constraints have to be copied from the backend, this can be quite an expensive operation, and so should not be called in a loop. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Constraint&lt;double&gt;&gt; </dd></dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#a4ec22b4a508690a7c3a1c32e704fcd71">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea47e04c749b212d1d7d408bcd8283f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlpint_1_1Objective.html">Objective</a>&lt;double&gt; lpint::LinearProgramHandleGurobi::objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the objective function of the internal LP. This method requests the objective function values from the LP backend, copies them, and returns them. Since the objective values have to be copied from the backend, this can be quite an expensive operation, and so should not be called in a loop. </p>
<dl class="section return"><dt>Returns</dt><dd>Objective&lt;double&gt; </dd></dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#a165514eb77acb57c814c58eb2e513dbf">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="a8fda3e9b72ded006264ff0dc39da3e32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lpint::LinearProgramHandleGurobi::remove_constraint </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a constraint from the LP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the constraint to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#a0c4435d4481134d3bade25de97703369">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="a2ba12d8c2dfc3e7303dc67874534278a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lpint::LinearProgramHandleGurobi::remove_variable </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a variable from the LP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of variable to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#ac743b6162cfe676a5b802663e7aa6fb6">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="acb278eeedf4fdeb7e7756d09692fe9df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlpint_1_1Variable.html">Variable</a> lpint::LinearProgramHandleGurobi::variable </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve variable i from the internal LP solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of variable to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Variable&gt; Vector containing internal LP variables. </dd></dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#a149193487b49b4421cfab9aba704b751">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<a class="anchor" id="a293508ed47cf1fa360d32cd7a2fe1acd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classlpint_1_1Variable.html">Variable</a>&gt; lpint::LinearProgramHandleGurobi::variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the variables from the internal LP solver. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Variable&gt; Vector containing internal LP variables. </dd></dl>

<p>Implements <a class="el" href="classlpint_1_1ILinearProgramHandle.html#adca5bfbccdaca2ab601273d6f6cc6b90">lpint::ILinearProgramHandle</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/lpinterface/gurobi/<a class="el" href="lphandle__gurobi_8hpp_source.html">lphandle_gurobi.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
